SECTION1: UNDERSTANDING "TESTS"
1) Intro
2) jest vs RTL: react testing library is actual testing, meanwhile jest is an additional addon on it
3) types of test: unit, integration, e2e test
4) what is test: Making sure a flow runs properly. with automation we can test wihtout manual intervention (whihc will take time).
5) project setup: npm install jest and react-testing-library for react. and a testing file will look like component.test.js
6) running test: "npm test" will test a component and show output with pass or fail. 1 test suites means 1 test file.
7) anatomy of a test: test, render, screen, expect
8) your first test: testing a component, whether is hello world is rendered in the page (vitual dom)
9) test driven development: first writing a test and after that developing the component. (rare usecase for me)
SECTION2: BASICS FOUNDATIONS TO KNOW
10) jest watch mode: watch is a thing we can ask a jest to watch what are all changed after the last commit, and excecute only that test. 
11) filtering test: w for watch, after w - a for all test, o for watch only changed files, p for testing a specific file (asks regex pattern for filter), t for test name (only one test)(asks regex pattern for filter), c for clearing filter, test.only(will run only this test), test.skip(will skip this test)
12) grouping test: describe method, descrive can also have child describe method, we can group as we need.
13) filename conventions: test.js, spec.js, __tests__. Can use test() or it() test.only() === fit() || test.skip() === xit() (will exclude it)
14) code coverage: we can check how much code is covered in test, ignore specific file types for testing coverage (this can used for checking how much overall components and codes are covered in testing) (rarely used, but good to know this option is there)
15) Assertions: expectin some values to be met. expect, matchers(tobetruthy, falsy, getmatch, tobeequal. tobegreaterthan, not.match, toThrow error. tobeinthedocument, tobeenabled,visible is a jest custom matcher)
16) what to test: rendering, prop sharing, conditional rendering, clicking events. not to test=> functionalties, 3rd party plugins, codes not important for the user
SECTION3: TARGETING ELEMENTS
17) RTL queries: getby, findby, queryby, getallby, findallby, queryallby, text, placeholdertext, role, label, displayvalue, title, alttext, testid
18) getbyrole: aria role elements
19) getbyrole options: name, levels (there are others, which will use in future based on requirements and needs)
20) getByLabelText
21) getByPlaceholderText
22) getByText
23) getByDisplayValue: textbox, checkbox, select values
24) getbyalttext: for image or other elements which accepts alt attribute
25) getbytitle title attribute
26) getbytestid
27) priority order: [role, lable, placeholder, text, display value], [alttext, title], [testid]
SECTION4: QUERIES
28) query multiple elements: getAllByRole, we can check multiple elements using array concepts with tobelenght method or something like that.
29) Textmatch: getByText("normal text"), getByText(/regex/i), getByText(text => text.startsWith("test"))
30) queryBy: queryby returns null if not in the document instead of error
31) findBy: this return a promise, resolve if mathces or reject if not matches within the default time of 1000ms, we can set manual time for waiting. use async await since it is promise.
32) Manual queries: we can use DOM queryselector if we want, but not recommemder since this is not visible to the user document.querySelector([data-element="foo"])
33) debugging: screen.debug = for checking html strcture at any point of the testing. logRoles to see what roles are present in the component
34) testing playground chrome extension: used to target the html element with best practice. - currently not working, but will be good if we personally have a tool like this locally.
SECTION5: USER INTERACTION
35) user interation: user-events, fireevents. user events behaves like user(focuses field, types value). fireevent do only specific dom manipulations. so user events is recommended.
36) pointer interations: Convenience api: [click, dblClick, tripleClick, hover, unhover], Pointer api: [pointer({keys: '[Mouseleft]'}), pointer({keys: '[Mouseleft, MouseRight]'})], utility api: [clear (input field), select (listbox), deselect(listbox)], clipboard api: [copy cut paste], keyboard api: [keyboard, {shift>}A{/shift}]
37) keyboard interations: type, tab
SECTION6: PROVIDERS AND CUSTOM HOOKS
38) providers: tutorial video covers MUI and provider, but we know redux and context and router provider concepts
39) Custom render function: (most likely will be used rarely)
40) custom react hooks: renderhook in const {result}. result.current.count to target the values || for property passing, use initialProps onject for passing in renderhook as second argument || use act(() => result.current.increment()) to write any updation checking. (use this for amny function checkng may be)
41) Act utility: act utility function is where a state update should be wrapped inside a act(() => {}) function before assertion. rtl wrapps all state updates around it act function, so please wrap the state update function inside the act function. || custom hook called with direct param (initialValue = 0, updateValyeBy = 10) can be called by render(() => useCounter(0, 10)) || if param is like inside obj ({initialValue = 0, updateValyeBy = 10}) the should be called in initialProps alone.
SECTION 7: MOCKING
42) 
43) 
44) 
45) 
46) 
47) 
48) 
49) 
50) 
51) 
53) 