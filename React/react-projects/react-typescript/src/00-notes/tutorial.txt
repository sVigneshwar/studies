React typescript tutorial:
1) Intro - what and why
2) Getting started - setting up project folders
3) typing props (Greet component)
example: 
- Greet component with name prop of type string
4) Basic Props: (Greet, Person, PersonList components)
example: 
- Greet with number of message(number) and isLoggedIn (boolean)
- Person component with name object containing first and last name (object) 
- PersonList component with array of person objects (array)
5) Advanced Props (Status, Heading, Oscar, Greet components)
example:
- Status component with status prop of specific string values (literal types)
- Heading component with children prop (children: string)
- Oscar component with children prop (children: React.ReactNode)
- Greet component with optional props (message?: number)
6) event props (Button, Input components)
example:
- Button component with onClick event handler (event: React.MouseEvent<HTMLButtonElement>)
- Input component with onChange event handler (event: React.ChangeEvent<HTMLInputElement>)
- These 2 handlers are the most common event handlers in React, so it's important to know how to type them correctly in TypeScript.
- there are other useful event handlers like form submit, keyboard events, etc.
7) Style props (Container component)
- Container component with styles prop (styles: React.CSSProperties)
8) Prop types and tips (Person component)
- we can destructure props directly in the function parameter list
- we can keep types in separate files for better organization
- we can call another type inside a type and use it elsewhere (nameList: Name[] - Here Name is another type defined separately {first: string, last:string})
**(Basically while passing any props, we should always use "type componentProps = {propname: proptype}", we cannot target without prop names)
9) useState with types (LoggedIn component)
- TS will automatically infer types based on initial state 
10) useState with future values: (User component)
- we need to explicitly define the type when the initial state is null or undefined
- this <> syntax is called generics in TS
11) useState type assertion (User component)
- we can use "as" keyword to assert a type when we are sure about the type
example:
- const [user, setUser] = useState<User | null>(null);
12) useReducer with types (Counter component)
- we need to define types for state and action
13) useReducer with strict action types (Counter component)
- we can use discriminated unions to define action types more strictly
example:
- type Action = { type: 'increment' } | { type: 'decrement' } | { type: 'reset' };
- union means we can have multiple types for a single variable (type A = B | C) (type A = string | number)
- literal means specific value for a type (type A = 'value1' | 'value2')
14) useContext hook (ThemeContext, Box.tsx components)
- we need to define the context type when creating context
- ts auto infers the type when using useContext hook if we know the context type
15) useContext future value (UserContext, User.tsx components)
- we need to handle the case when context value is null or undefined
- we can use non-null assertion operator (!) when we are sure the context will not be null
- use type assertion when creating context with default null value
- in provider value we need to provide the correct type if we are passing multiple values
16) useRef with types (DomRef (DomRef.tsx), MutableRef (Timer.tsx) components)
- we need to define the type of the ref element when using useRef hook
- for DOM elements we can use React.RefObject<HTMLElementType>
- for mutable values we can use React.MutableRefObject<Type>
example:
- const inputRef = useRef<HTMLInputElement>(null);
- const countRef = useRef<number>(0);
17) class components with types
- we need to define types for props and state
- we can use React.Component<PropsType, StateType>
- for now class components are not used, so will not focus much on this
18) Passing component as props (Private, Profile, PrivatePerson components)
- we can pass components as props using React.ComponentType<Props>
19) Generic props (List component)
- we can set generic type parameters for components
- this allows us to create reusable components that can work with different types
example:
- const List = <T extends {}>({ items, render }: ListProps<T>) => { ... }
- we can also set <T extends string | number> if we want to restrict to specific types
20) Restricting props (GetRandomNumber component)
- we can restrict a components props based on other props using union
example:
- type RandomNumberProps = 
    | { value: number; isPositive: true; isNegative?: never; isZero?: never } 
    | { value: number; isPositive?: never; isNegative: true; isZero?: never } 
    | { value: number; isPositive?: never; isNegative?: never; isZero: true };
21) template literals and Exclude utility type (Toast component)
- we can create custom string types using template literals
- we can use Exclude utility type to exclude specific types from a union
22) 